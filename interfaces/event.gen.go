// Package interfaces provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package interfaces

import (
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List categories
	// (GET /category)
	ListCategories(c *gin.Context, params ListCategoriesParams)
	// Get category info
	// (GET /category/{categoryKey})
	GetCategory(c *gin.Context, categoryKey string)
	// List competitions
	// (GET /competition)
	ListCompetitions(c *gin.Context, params ListCompetitionsParams)
	// Get competition info
	// (GET /competition/{competitionKey})
	GetCompetition(c *gin.Context, competitionKey string)
	// List events
	// (GET /event)
	ListEvents(c *gin.Context, params ListEventsParams)
	// Get event info
	// (GET /event/{eventKey})
	GetEvent(c *gin.Context, eventKey string)
	// List sports
	// (GET /sport)
	ListSports(c *gin.Context, params ListSportsParams)
	// Get sport info
	// (GET /sport/{sportKey})
	GetSport(c *gin.Context, sportKey string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// ListCategories operation middleware
func (siw *ServerInterfaceWrapper) ListCategories(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCategoriesParams

	// ------------- Required query parameter "first" -------------
	if paramValue := c.Query("first"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument first is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "first", c.Request.URL.Query(), &params.First)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter first: %s", err)})
		return
	}

	// ------------- Required query parameter "page" -------------
	if paramValue := c.Query("page"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument page is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter page: %s", err)})
		return
	}

	// ------------- Optional query parameter "sport" -------------
	if paramValue := c.Query("sport"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sport", c.Request.URL.Query(), &params.Sport)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter sport: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.ListCategories(c, params)
}

// GetCategory operation middleware
func (siw *ServerInterfaceWrapper) GetCategory(c *gin.Context) {

	var err error

	// ------------- Path parameter "categoryKey" -------------
	var categoryKey string

	err = runtime.BindStyledParameter("simple", false, "categoryKey", c.Param("categoryKey"), &categoryKey)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter categoryKey: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetCategory(c, categoryKey)
}

// ListCompetitions operation middleware
func (siw *ServerInterfaceWrapper) ListCompetitions(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCompetitionsParams

	// ------------- Required query parameter "first" -------------
	if paramValue := c.Query("first"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument first is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "first", c.Request.URL.Query(), &params.First)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter first: %s", err)})
		return
	}

	// ------------- Required query parameter "page" -------------
	if paramValue := c.Query("page"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument page is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter page: %s", err)})
		return
	}

	// ------------- Optional query parameter "sport" -------------
	if paramValue := c.Query("sport"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sport", c.Request.URL.Query(), &params.Sport)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter sport: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.ListCompetitions(c, params)
}

// GetCompetition operation middleware
func (siw *ServerInterfaceWrapper) GetCompetition(c *gin.Context) {

	var err error

	// ------------- Path parameter "competitionKey" -------------
	var competitionKey string

	err = runtime.BindStyledParameter("simple", false, "competitionKey", c.Param("competitionKey"), &competitionKey)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter competitionKey: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetCompetition(c, competitionKey)
}

// ListEvents operation middleware
func (siw *ServerInterfaceWrapper) ListEvents(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEventsParams

	// ------------- Required query parameter "first" -------------
	if paramValue := c.Query("first"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument first is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "first", c.Request.URL.Query(), &params.First)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter first: %s", err)})
		return
	}

	// ------------- Required query parameter "page" -------------
	if paramValue := c.Query("page"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument page is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter page: %s", err)})
		return
	}

	// ------------- Optional query parameter "sport" -------------
	if paramValue := c.Query("sport"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sport", c.Request.URL.Query(), &params.Sport)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter sport: %s", err)})
		return
	}

	// ------------- Optional query parameter "competition" -------------
	if paramValue := c.Query("competition"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "competition", c.Request.URL.Query(), &params.Competition)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter competition: %s", err)})
		return
	}

	// ------------- Optional query parameter "category" -------------
	if paramValue := c.Query("category"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "category", c.Request.URL.Query(), &params.Category)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter category: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.ListEvents(c, params)
}

// GetEvent operation middleware
func (siw *ServerInterfaceWrapper) GetEvent(c *gin.Context) {

	var err error

	// ------------- Path parameter "eventKey" -------------
	var eventKey string

	err = runtime.BindStyledParameter("simple", false, "eventKey", c.Param("eventKey"), &eventKey)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter eventKey: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetEvent(c, eventKey)
}

// ListSports operation middleware
func (siw *ServerInterfaceWrapper) ListSports(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSportsParams

	// ------------- Required query parameter "first" -------------
	if paramValue := c.Query("first"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument first is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "first", c.Request.URL.Query(), &params.First)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter first: %s", err)})
		return
	}

	// ------------- Required query parameter "page" -------------
	if paramValue := c.Query("page"); paramValue != "" {

	} else {
		c.JSON(http.StatusBadRequest, gin.H{"msg": "Query argument page is required, but not found"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter page: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.ListSports(c, params)
}

// GetSport operation middleware
func (siw *ServerInterfaceWrapper) GetSport(c *gin.Context) {

	var err error

	// ------------- Path parameter "sportKey" -------------
	var sportKey string

	err = runtime.BindStyledParameter("simple", false, "sportKey", c.Param("sportKey"), &sportKey)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter sportKey: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetSport(c, sportKey)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/category", wrapper.ListCategories)

	router.GET(options.BaseURL+"/category/:categoryKey", wrapper.GetCategory)

	router.GET(options.BaseURL+"/competition", wrapper.ListCompetitions)

	router.GET(options.BaseURL+"/competition/:competitionKey", wrapper.GetCompetition)

	router.GET(options.BaseURL+"/event", wrapper.ListEvents)

	router.GET(options.BaseURL+"/event/:eventKey", wrapper.GetEvent)

	router.GET(options.BaseURL+"/sport", wrapper.ListSports)

	router.GET(options.BaseURL+"/sport/:sportKey", wrapper.GetSport)

	return router
}
