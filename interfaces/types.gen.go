// Package interfaces provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package interfaces

import (
	"encoding/json"
	"fmt"
)

// Defines values for SelectionSide.
const (
	BACK SelectionSide = "BACK"
	LAY  SelectionSide = "LAY"
)

// Defines values for SelectionStatus.
const (
	SELECTIONDISABLED SelectionStatus = "SELECTION_DISABLED"
	SELECTIONENABLED  SelectionStatus = "SELECTION_ENABLED"
)

// Category defines model for Category.
type Category struct {
	// category key
	Key string `json:"key"`

	// category name
	Name *string `json:"name,omitempty"`
}

// Competition defines model for Competition.
type Competition struct {
	// competition key
	Key string `json:"key"`

	// competition name
	Name *string `json:"name,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Error *string `json:"error,omitempty"`
}

// Event defines model for Event.
type Event struct {
	Active bool  `json:"active"`
	Away   *Team `json:"away,omitempty"`

	// category
	Category *struct {
		// category key
		Key *string `json:"key,omitempty"`

		// category name
		Name *string `json:"name,omitempty"`
	} `json:"category,omitempty"`

	// competition
	Competition *struct {
		// competition key
		Key *string `json:"key,omitempty"`

		// competition name
		Name *string `json:"name,omitempty"`
	} `json:"competition,omitempty"`

	// Cut off time
	CutOffTime *string `json:"cutOffTime,omitempty"`
	Home       *Team   `json:"home,omitempty"`

	// time that changed status to inactive
	InactiveTime *string `json:"inactiveTime,omitempty"`

	// event key
	Key string `json:"key"`

	// market info
	Market *Event_Market `json:"market,omitempty"`

	// event name
	Name *string `json:"name,omitempty"`

	// sport info
	Sport *struct {
		// sport key
		Key *string `json:"key,omitempty"`

		// sport name
		Name *string `json:"name,omitempty"`
	} `json:"sport,omitempty"`

	// time that changed status to TRADING_LIVE
	StartTradingLiveTime *string `json:"startTradingLiveTime,omitempty"`
}

// market info
type Event_Market struct {
	AdditionalProperties map[string]Market `json:"-"`
}

// Market defines model for Market.
type Market struct {
	Submarkets *Market_Submarkets `json:"submarkets,omitempty"`
}

// Market_Submarkets defines model for Market.Submarkets.
type Market_Submarkets struct {
	AdditionalProperties map[string][]Selection `json:"-"`
}

// Selection defines model for Selection.
type Selection struct {
	// maximum stake in EUR which can be placed in bets on this Selection; market liability = selection max stake * (price - 1);
	MaxStake *float64 `json:"maxStake,omitempty"`

	// minimum stake in EUR which can be placed in bets on this Selection
	MinStake *float64 `json:"minStake,omitempty"`
	Outcome  *string  `json:"outcome,omitempty"`
	Params   *string  `json:"params,omitempty"`

	// price at which bets can be placed on this Selection
	Price       *float64 `json:"price,omitempty"`
	Probability *float64 `json:"probability,omitempty"`

	// Side of a selection signals whether a selection is available for back or lay side betting
	Side *SelectionSide `json:"side,omitempty"`

	// SelectionStatus presents the current status for a given selection
	Status *SelectionStatus `json:"status,omitempty"`
}

// Side of a selection signals whether a selection is available for back or lay side betting
type SelectionSide string

// SelectionStatus presents the current status for a given selection
type SelectionStatus string

// Sport defines model for Sport.
type Sport struct {
	// sport key
	Key string `json:"key"`

	// average time of event stay in trading_live status
	LiveTime *float64 `json:"liveTime,omitempty"`

	// sport name
	Name *string `json:"name,omitempty"`
}

// Team defines model for Team.
type Team struct {
	// Abbreviation
	Abbreviation *string `json:"abbreviation,omitempty"`

	// team key
	Key string `json:"key"`

	// team name
	Name *string `json:"name,omitempty"`

	// Nationality
	Nationality *string `json:"nationality,omitempty"`
}

// CategoryKey defines model for CategoryKey.
type CategoryKey = string

// CompetitionKey defines model for CompetitionKey.
type CompetitionKey = string

// First defines model for First.
type First = int32

// Page defines model for Page.
type Page = int32

// SportKey defines model for SportKey.
type SportKey = string

// ListCategoriesParams defines parameters for ListCategories.
type ListCategoriesParams struct {
	// first n items to be queried
	First First `form:"first" json:"first"`

	// page number
	Page Page `form:"page" json:"page"`

	// sport key for filtering
	Sport *SportKey `form:"sport,omitempty" json:"sport,omitempty"`
}

// ListCompetitionsParams defines parameters for ListCompetitions.
type ListCompetitionsParams struct {
	// first n items to be queried
	First First `form:"first" json:"first"`

	// page number
	Page Page `form:"page" json:"page"`

	// sport key for filtering
	Sport *SportKey `form:"sport,omitempty" json:"sport,omitempty"`
}

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// first n items to be queried
	First First `form:"first" json:"first"`

	// page number
	Page Page `form:"page" json:"page"`

	// sport key for filtering
	Sport *SportKey `form:"sport,omitempty" json:"sport,omitempty"`

	// competition key for filtering
	Competition *CompetitionKey `form:"competition,omitempty" json:"competition,omitempty"`

	// category key for filtering
	Category *CategoryKey `form:"category,omitempty" json:"category,omitempty"`
}

// ListSportsParams defines parameters for ListSports.
type ListSportsParams struct {
	// first n items to be queried
	First First `form:"first" json:"first"`

	// page number
	Page Page `form:"page" json:"page"`
}

// Getter for additional properties for Event_Market. Returns the specified
// element and whether it was found
func (a Event_Market) Get(fieldName string) (value Market, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Event_Market
func (a *Event_Market) Set(fieldName string, value Market) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Market)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Event_Market to handle AdditionalProperties
func (a *Event_Market) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Market)
		for fieldName, fieldBuf := range object {
			var fieldVal Market
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Event_Market to handle AdditionalProperties
func (a Event_Market) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Market_Submarkets. Returns the specified
// element and whether it was found
func (a Market_Submarkets) Get(fieldName string) (value []Selection, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Market_Submarkets
func (a *Market_Submarkets) Set(fieldName string, value []Selection) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]Selection)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Market_Submarkets to handle AdditionalProperties
func (a *Market_Submarkets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]Selection)
		for fieldName, fieldBuf := range object {
			var fieldVal []Selection
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Market_Submarkets to handle AdditionalProperties
func (a Market_Submarkets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
